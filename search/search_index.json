{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to OverrunGL Book \u00b6 This book introduced writing 3D game with OverrunGL . OverrunGL is a high performance library binding OpenGL. In this tutorial, we will learn the basic of game engine working. If you got a question, please check or create a discussion . Click the \u201cNext\u201d button to start our travel!","title":"Introduction"},{"location":"#welcome-to-overrungl-book","text":"This book introduced writing 3D game with OverrunGL . OverrunGL is a high performance library binding OpenGL. In this tutorial, we will learn the basic of game engine working. If you got a question, please check or create a discussion . Click the \u201cNext\u201d button to start our travel!","title":"Welcome to OverrunGL Book"},{"location":"1-preparing/","text":"Preparing \u00b6 Before staring, we need to prepare our project. We will use Java 19 for our project. Add the dependencies to your build script. In the future, we can use the customizer to generate the dependencies. Also, remember to enable the preview features. // Groovy project.ext.overrunglVer = \"0.1.0\" project.ext.overrunglNatives = \"natives-windows\" dependencies { implementation platform(\"io.github.over-run:overrungl-bom:$overrunglVer\") implementation \"io.github.over-run:overrungl\" implementation \"io.github.over-run:overrungl-glfw\" implementation \"io.github.over-run:overrungl-opengl\" implementation \"io.github.over-run:overrungl-stb\" runtimeOnly \"io.github.over-run:overrungl-glfw::$overrungNatives\" runtimeOnly \"io.github.over-run:overrungl-stb::$overrungNatives\" } tasks.withType(JavaCompile).configureEach { options.compilerArgs += \"--enable-preview\" } // Kotlin DSL Script val overrunglVer = \"0.1.0\" dependencies { implementation(platform(\"io.github.over-run:overrungl-bom:$overrunglVer\")) implementation(\"io.github.over-run:overrungl\") implementation(\"io.github.over-run:overrungl-glfw\") implementation(\"io.github.over-run:overrungl-opengl\") implementation(\"io.github.over-run:overrungl-stb\") runtimeOnly(\"io.github.over-run\", \"overrungl-glfw\", classifier = overrungNatives) runtimeOnly(\"io.github.over-run\", \"overrungl-stb\", classifier = overrungNatives) } tasks.withType<JavaCompile> { options.compilerArgs.add(\"--enable-preview\") } If you had used LWJGL before, you may see that the there is no native for core and OpenGL module. This because the OpenGL module used core and GLFW module to load functions, and we don't have to build shared libraries for it. To get started with OverrunGL, we use this example . You can see we are using GLFW for our window, so we can interact with mouse, keyboard even controllers. If all works, you will get a red window like this below.","title":"Preparing"},{"location":"1-preparing/#preparing","text":"Before staring, we need to prepare our project. We will use Java 19 for our project. Add the dependencies to your build script. In the future, we can use the customizer to generate the dependencies. Also, remember to enable the preview features. // Groovy project.ext.overrunglVer = \"0.1.0\" project.ext.overrunglNatives = \"natives-windows\" dependencies { implementation platform(\"io.github.over-run:overrungl-bom:$overrunglVer\") implementation \"io.github.over-run:overrungl\" implementation \"io.github.over-run:overrungl-glfw\" implementation \"io.github.over-run:overrungl-opengl\" implementation \"io.github.over-run:overrungl-stb\" runtimeOnly \"io.github.over-run:overrungl-glfw::$overrungNatives\" runtimeOnly \"io.github.over-run:overrungl-stb::$overrungNatives\" } tasks.withType(JavaCompile).configureEach { options.compilerArgs += \"--enable-preview\" } // Kotlin DSL Script val overrunglVer = \"0.1.0\" dependencies { implementation(platform(\"io.github.over-run:overrungl-bom:$overrunglVer\")) implementation(\"io.github.over-run:overrungl\") implementation(\"io.github.over-run:overrungl-glfw\") implementation(\"io.github.over-run:overrungl-opengl\") implementation(\"io.github.over-run:overrungl-stb\") runtimeOnly(\"io.github.over-run\", \"overrungl-glfw\", classifier = overrungNatives) runtimeOnly(\"io.github.over-run\", \"overrungl-stb\", classifier = overrungNatives) } tasks.withType<JavaCompile> { options.compilerArgs.add(\"--enable-preview\") } If you had used LWJGL before, you may see that the there is no native for core and OpenGL module. This because the OpenGL module used core and GLFW module to load functions, and we don't have to build shared libraries for it. To get started with OverrunGL, we use this example . You can see we are using GLFW for our window, so we can interact with mouse, keyboard even controllers. If all works, you will get a red window like this below.","title":"Preparing"},{"location":"2-game-loop/","text":"The Game Loop \u00b6 In this chapter, we will create a game loop for our game engine. The game loop is the core in our engine. It updates the framebuffer, processes the input and display to the screen, until the game engine exits. This pseudocode shows the basic logic of the game loop. while (running) { update(); render(); post_processing(); } This is just a simple example. We must use a Timer to calculate the interval (called delta ) of the last and current running time. We can use a simple timer. It computes the delta, so we can use it for the scaling factor. double lastTime, currentTime, delta; while (running) { lastTime = currentTime; currentTime = getCurrentTime(); delta = currentTime - lastTime; update(); render(); post_processing(); }","title":"The Game Loop"},{"location":"2-game-loop/#the-game-loop","text":"In this chapter, we will create a game loop for our game engine. The game loop is the core in our engine. It updates the framebuffer, processes the input and display to the screen, until the game engine exits. This pseudocode shows the basic logic of the game loop. while (running) { update(); render(); post_processing(); } This is just a simple example. We must use a Timer to calculate the interval (called delta ) of the last and current running time. We can use a simple timer. It computes the delta, so we can use it for the scaling factor. double lastTime, currentTime, delta; while (running) { lastTime = currentTime; currentTime = getCurrentTime(); delta = currentTime - lastTime; update(); render(); post_processing(); }","title":"The Game Loop"}]}